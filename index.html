<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>voidX744 — Latest Videos</title>
  <style>
    /* --- Basic page layout --- */
    :root{--bg:#f7f8fb;--card:#fff;--muted:#6b7280;--accent:#111827}
    *{box-sizing:border-box}
    body{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; margin:0; background:var(--bg); color:var(--accent); -webkit-font-smoothing:antialiased}
    header{padding:2rem 1rem 0; text-align:center}
    h1{margin:0;font-size:1.6rem}
    p.tagline{margin:.35rem 0 1.25rem;color:var(--muted)}

    /* --- Grid of video cards --- */
    .videos {display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:1rem;padding:1rem;max-width:1100px;margin:0 auto}
    .card{background:var(--card);border-radius:12px;overflow:hidden;box-shadow:0 6px 20px rgba(16,24,40,.06);transition:transform .18s ease,box-shadow .18s ease}
    .card:hover{transform:translateY(-6px);box-shadow:0 12px 30px rgba(16,24,40,.08)}

    /* Responsive 16:9 iframe container inside card */
    .video-wrap{position:relative;padding-bottom:56.25%;height:0;background:#000}
  .video-wrap iframe{position:absolute;top:0;left:0;width:100%;height:100%;border:0}
  /* Thumbnail overlay (loads lighter than iframe) */
  .thumb{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#000;color:#fff;cursor:pointer}
  .thumb img{width:100%;height:100%;object-fit:cover;display:block}
  .play-btn{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:64px;height:64px;border-radius:50%;background:rgba(17,24,39,.85);display:flex;align-items:center;justify-content:center}
  .play-btn:after{content:'';display:block;margin-left:3px;border-style:solid;border-width:10px 0 10px 16px;border-color:transparent transparent transparent #fff}

    .meta{padding:0.8rem 1rem}
    .title{font-size:1rem;margin:0 0 .35rem}
    .date{font-size:.85rem;color:var(--muted);margin:0}

    /* Load more button */
    .load-more{display:block;margin:1.25rem auto 3rem;padding:.6rem 1.1rem;border-radius:10px;background:#111827;color:#fff;border:0;cursor:pointer;box-shadow:0 6px 18px rgba(17,24,39,.08)}
    .load-more:hover{transform:translateY(-3px)}

  /* status area */
  .status{max-width:1100px;margin:0.5rem auto 0;padding:0 1rem;color:var(--muted);font-size:.95rem}

    /* Helpful small-screen padding */
    @media (max-width:420px){header{padding:1.25rem 0}.videos{padding:0.5rem}}
  </style>
</head>
<body>
  <!-- Header -->
  <header>
    <p class="tagline">Latest videos from the voidX744</p>
  </header>

  <!-- Container for the video grid -->
  <main>
    <div id="videos" class="videos" aria-live="polite">
      <!-- Video cards will be injected here by JavaScript -->
    </div>

    <!-- Load more button: reveals additional videos beyond initial set -->
    <button id="loadMore" class="load-more" style="display:none">Load more videos</button>
    <div id="status" class="status" aria-hidden="false">
      <button id="proxyThumbs" style="display:none;margin-left:.5rem;padding:.3rem .6rem;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer">Try proxy thumbnails</button>
    </div>
  </main>

  <script>
  /*
    Script: Fetch YouTube channel RSS via a CORS proxy (AllOrigins), parse XML,
    extract videoId, title, and published date, then render responsive embedded
    players in a grid. No API key required.

    Important: Uses public CORS proxy at https://api.allorigins.win/get?url=
    If running in production, consider hosting your own proxy or server-side
    fetch to avoid rate limits.
  */

  (function(){
    // Configuration
    const CHANNEL_RSS = 'https://www.youtube.com/feeds/videos.xml?channel_id=UCNZva9pv563Hc85ibd7O2UQ';
    const CORS_PROXY = 'https://api.allorigins.win/get?url='; // free proxy that returns {contents: '...'}
    const INITIAL_COUNT = 6; // number of videos to show before "Load more"

  // DOM references
  const videosEl = document.getElementById('videos');
  const loadBtn = document.getElementById('loadMore');
  const statusEl = document.getElementById('status');
  const proxyThumbsBtn = document.getElementById('proxyThumbs');

  // Whether to fetch thumbnails via an image proxy (settable by user)
  let useImageProxy = false;

  // Track thumbnail load failures to suggest proxying thumbnails
  let thumbnailFailures = 0;

  // Simple image proxy prefix (no API key) - uses weserv.nl which can fetch remote images
  const IMAGE_PROXY_PREFIX = 'https://images.weserv.nl/?url='; // append encoded remote URL

  proxyThumbsBtn.addEventListener('click', () => {
    useImageProxy = true;
    proxyThumbsBtn.style.display = 'none';
    statusEl.textContent = 'Using proxy thumbnails; reloading...';
    // reload videos to update thumbnails
    loadVideos();
  });

  function showProxySuggestion(){
    if (!useImageProxy){
      proxyThumbsBtn.style.display = 'inline-block';
      statusEl.textContent = 'Some thumbnails failed to load — you can try proxy thumbnails.';
    }
  }

    // Helper: format ISO date to a friendly string
    function formatDate(iso){
      try{
        const d = new Date(iso);
        return d.toLocaleDateString(undefined, {year:'numeric', month:'short', day:'numeric'});
      }catch(e){return iso}
    }

    // Helper: create a single video card element with a thumbnail overlay
    function createCard(video){
      const card = document.createElement('article');
      card.className = 'card';

      // Video container (responsive 16:9)
      const wrap = document.createElement('div');
      wrap.className = 'video-wrap';

      // Thumbnail overlay (YouTube default thumbnail URL)
      const thumb = document.createElement('div');
      thumb.className = 'thumb';
      const img = document.createElement('img');
      // If the RSS provided a thumbnail URL, prefer it first
      const fallbacks = [];
      if (video.thumbnail) {
        fallbacks.push(video.thumbnail);
      }
      // Try i.ytimg fallbacks after RSS-provided URL
      const base = `https://i.ytimg.com/vi/${encodeURIComponent(video.id)}`;
      fallbacks.push(`${base}/maxresdefault.jpg`);
      fallbacks.push(`${base}/hqdefault.jpg`);
      fallbacks.push(`${base}/sddefault.jpg`);
      fallbacks.push(`${base}/default.jpg`);
      let fbIndex = 0;
      img.alt = video.title;
      img.loading = 'lazy';

      // Preload thumbnails via Image() to confirm availability before assigning
      function tryLoadThumb(index){
        if (index >= fallbacks.length){
          // all failed => placeholder
          img.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
            <svg xmlns="http://www.w3.org/2000/svg" width="480" height="270">
              <rect width="100%" height="100%" fill="#111827"/>
              <text x="50%" y="50%" fill="#ffffff" font-family="Arial, Helvetica, sans-serif" font-size="18" dominant-baseline="middle" text-anchor="middle">No thumbnail</text>
            </svg>
          `);
          console.debug('Thumbnail: no available thumbnail for', video.id);
          // increment failure counter and suggest proxy if needed
          thumbnailFailures += 1;
          showProxySuggestion();
          return;
        }
        let testUrl = fallbacks[index];
        if (useImageProxy){
          testUrl = IMAGE_PROXY_PREFIX + encodeURIComponent(testUrl.replace(/^https?:\/\//,'') );
        }
        const tester = new Image();
        tester.onload = function(){
          img.src = testUrl; // set working src
          console.debug('Thumbnail loaded from', testUrl);
        };
        tester.onerror = function(){
          // try next fallback
          tryLoadThumb(index + 1);
        };
        // start test (this triggers the request)
        tester.src = testUrl;
      }
      // start trying fallbacks
      tryLoadThumb(fbIndex);

      const play = document.createElement('div');
      play.className = 'play-btn';

      thumb.appendChild(img);
      thumb.appendChild(play);

      // When clicked, replace the thumb with the iframe (lazy load)
      thumb.addEventListener('click', () => {
        const iframe = document.createElement('iframe');
        iframe.src = 'https://www.youtube.com/embed/' + encodeURIComponent(video.id) + '?autoplay=1';
        iframe.title = video.title;
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframe.setAttribute('allowfullscreen','');
        // remove thumb and insert iframe
        wrap.innerHTML = '';
        wrap.appendChild(iframe);
      }, { once: true });

      wrap.appendChild(thumb);

      // Meta (title + date)
      const meta = document.createElement('div');
      meta.className = 'meta';
      const title = document.createElement('h3');
      title.className = 'title';
      title.textContent = video.title;
      const date = document.createElement('p');
      date.className = 'date';
      date.textContent = formatDate(video.published);

      meta.appendChild(title);
      meta.appendChild(date);

      card.appendChild(wrap);
      card.appendChild(meta);
      return card;
    }

    // Parse the XML text and extract video entries
    function parseRss(xmlText){
      // AllOrigins returns a JSON object with `contents` containing the XML
      // If xmlText already contains '<' then assume it's raw XML
      const raw = xmlText.trim().startsWith('<') ? xmlText : (function(){ try{ return JSON.parse(xmlText).contents }catch(e){ return xmlText }} )();
      const parser = new DOMParser();
      const doc = parser.parseFromString(raw, 'application/xml');

      // Handle parsererror
      if (doc.querySelector('parsererror')) throw new Error('Failed to parse RSS XML');

      // Use XML-safe methods (getElementsByTagName / localName) because selectors
      // with namespace prefixes like 'yt:videoId' are not valid for querySelector.
      const entries = Array.from(doc.getElementsByTagName('entry'));
      return entries.map(e => {
        // Try multiple ways to find the videoId (namespaced and non-namespaced)
        let idNode = e.getElementsByTagName('yt:videoId')[0] || e.getElementsByTagName('videoId')[0];
        if (!idNode) {
          // fallback: scan child nodes for localName === 'videoId'
          idNode = Array.from(e.childNodes).find(n => n && n.localName === 'videoId');
        }
        const id = idNode ? idNode.textContent.trim() : ((e.getElementsByTagName('id')[0] && e.getElementsByTagName('id')[0].textContent.trim()) || '');

        const titleNode = e.getElementsByTagName('title')[0];
        const publishedNode = e.getElementsByTagName('published')[0];
        const title = titleNode ? titleNode.textContent.trim() : '';
        const published = publishedNode ? publishedNode.textContent.trim() : '';
        // Try to extract thumbnail URL from RSS (media:thumbnail or media:group)
        let thumbUrl = null;
        // direct media:thumbnail elements often have a url attribute
        const mediaThumb = e.getElementsByTagName('media:thumbnail')[0];
        if (mediaThumb && mediaThumb.getAttribute) {
          thumbUrl = mediaThumb.getAttribute('url') || null;
        }
        // media:group -> media:thumbnail
        if (!thumbUrl) {
          const mediaGroup = e.getElementsByTagName('media:group')[0];
          if (mediaGroup) {
            const mt = mediaGroup.getElementsByTagName('media:thumbnail')[0] || mediaGroup.getElementsByTagName('thumbnail')[0];
            if (mt && mt.getAttribute) thumbUrl = mt.getAttribute('url') || null;
          }
        }
        // fallback: find any element named 'thumbnail' with url attribute
        if (!thumbUrl) {
          const anyThumb = Array.from(e.getElementsByTagName('*')).find(n => n && n.localName === 'thumbnail' && n.getAttribute && n.getAttribute('url'));
          if (anyThumb) thumbUrl = anyThumb.getAttribute('url');
        }

        return {id,title,published,thumbnail: thumbUrl};
      });
    }

    // Render a slice of videos to the grid
    function render(videos, count){
      videosEl.innerHTML = '';
      const slice = videos.slice(0, count);
      slice.forEach(v => videosEl.appendChild(createCard(v)));
    }

    // Main fetch + render flow
    // Try a list of CORS proxies in order with retry/backoff
    const PROXY_LIST = [
      'https://api.allorigins.win/get?url=',
      'https://api.codetabs.com/v1/proxy?quest=',
      'https://thingproxy.freeboard.io/fetch/'
    ];

    async function fetchWithFallback(url){
      const maxAttempts = PROXY_LIST.length;
      for (let i = 0; i < maxAttempts; i++){
        const proxy = PROXY_LIST[i];
        const fullUrl = proxy + encodeURIComponent(url);
        try{
          // simple fetch with no-store
          const resp = await fetch(fullUrl, { cache: 'no-store', mode: 'cors' });
          if (!resp.ok) throw new Error('proxy error ' + resp.status);
          // Different proxies return different shapes. Attempt to extract contents.
          const text = await resp.text();
          // AllOrigins returns JSON with `contents`; Codetabs returns the raw body; thingproxy returns raw body.
          if (text.trim().startsWith('{')){
            try{
              const j = JSON.parse(text);
              if (j && j.contents) return j.contents;
            }catch(e){ /* fallthrough */ }
          }
          // Not JSON, assume raw XML string
          return text;
        }catch(err){
          console.warn('Proxy failed:', proxy, err.message);
          // exponential backoff before next proxy
          await new Promise(r => setTimeout(r, 400 * Math.pow(2, i)));
        }
      }
      throw new Error('All proxies failed');
    }

    async function loadVideos(){
      try{
        statusEl.textContent = 'Fetching latest videos...';
        // reset thumbnail failure tracking each fetch
        thumbnailFailures = 0;
        const cacheBuster = 'cb=' + Date.now();
        const rssWithCb = CHANNEL_RSS + (CHANNEL_RSS.includes('?') ? '&' : '?') + cacheBuster;

        const raw = await fetchWithFallback(rssWithCb);
        const videos = parseRss(raw);

        if (videos.length === 0) {
          videosEl.innerHTML = '<p style="padding:1rem; color:var(--muted)">No videos found.</p>';
          statusEl.textContent = 'No videos found.';
          return;
        }

        // Initially show only INITIAL_COUNT
        let visible = Math.min(INITIAL_COUNT, videos.length);
        render(videos, visible);

        // Show load more button if there are more
        if (videos.length > INITIAL_COUNT){
          loadBtn.style.display = 'inline-block';
          loadBtn.onclick = () => {
            visible = videos.length; // reveal all
            render(videos, visible);
            loadBtn.style.display = 'none';
          };
        }

        statusEl.textContent = `Last fetched: ${new Date().toLocaleString()}`;
      }catch(err){
        console.error(err);
        videosEl.innerHTML = '<p style="padding:1rem; color:var(--muted)">Failed to load videos. Try again later.</p>';
        statusEl.textContent = 'Failed to fetch feed. Will retry on refresh.';
      }
    }

    // Start
    loadVideos();
  })();
  </script>
</body>
</html>
